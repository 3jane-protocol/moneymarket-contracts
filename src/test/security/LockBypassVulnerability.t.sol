// SPDX-License-Identifier: AGPL-3.0
pragma solidity ^0.8.18;

import {Setup} from "../utils/Setup.sol";
import {USD3} from "../../USD3.sol";
import {sUSD3} from "../../sUSD3.sol";
import {MorphoCredit} from "@3jane-morpho-blue/MorphoCredit.sol";
import {MockProtocolConfig} from "../mocks/MockProtocolConfig.sol";
import {IERC20} from "../../../lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
import {ITokenizedStrategy} from "@tokenized-strategy/interfaces/ITokenizedStrategy.sol";
import {TransparentUpgradeableProxy} from "../../../lib/openzeppelin-contracts/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";
import {ProxyAdmin} from "../../../lib/openzeppelin-contracts/contracts/proxy/transparent/ProxyAdmin.sol";
import {console2} from "forge-std/console2.sol";

/**
 * @title LockBypassVulnerability
 * @notice Tests for the reported sUSD3 lock-down period bypass vulnerability
 * @dev Verifies if users can bypass lock periods through cooldown manipulation
 */
contract LockBypassVulnerabilityTest is Setup {
    USD3 public usd3Strategy;
    sUSD3 public susd3Strategy;

    address public alice = makeAddr("alice");
    address public bob = makeAddr("bob");
    address public attacker = makeAddr("attacker");
    address public attackerAlt = makeAddr("attackerAlt");

    function setUp() public override {
        super.setUp();

        usd3Strategy = USD3(address(strategy));

        // Deploy sUSD3 implementation with proxy
        sUSD3 susd3Implementation = new sUSD3();

        // Deploy proxy admin
        address proxyAdminOwner = makeAddr("ProxyAdminOwner");
        ProxyAdmin susd3ProxyAdmin = new ProxyAdmin(proxyAdminOwner);

        // Deploy proxy with initialization
        bytes memory susd3InitData = abi.encodeWithSelector(
            sUSD3.initialize.selector,
            address(usd3Strategy),
            management,
            keeper
        );

        TransparentUpgradeableProxy susd3Proxy = new TransparentUpgradeableProxy(
                address(susd3Implementation),
                address(susd3ProxyAdmin),
                susd3InitData
            );

        susd3Strategy = sUSD3(address(susd3Proxy));

        // Link strategies
        vm.prank(management);
        usd3Strategy.setSUSD3(address(susd3Strategy));

        // Set protocol config parameters
        address morphoAddress = address(usd3Strategy.morphoCredit());
        address protocolConfigAddress = MorphoCredit(morphoAddress)
            .protocolConfig();

        // Set lock duration to 90 days
        MockProtocolConfig(protocolConfigAddress).setConfig(
            keccak256("SUSD3_LOCK_DURATION"),
            90 days
        );

        // Set cooldown period to 7 days
        MockProtocolConfig(protocolConfigAddress).setConfig(
            keccak256("SUSD3_COOLDOWN_PERIOD"),
            7 days
        );

        // Set withdrawal window to 2 days
        MockProtocolConfig(protocolConfigAddress).setConfig(
            keccak256("SUSD3_WITHDRAWAL_WINDOW"),
            2 days
        );

        // Fund test users
        airdrop(asset, alice, 10000e6);
        airdrop(asset, bob, 10000e6);
        airdrop(asset, attacker, 10000e6);
        airdrop(asset, attackerAlt, 10000e6);

        // Setup whitelist
        vm.startPrank(management);
        usd3Strategy.setWhitelistEnabled(true);
        usd3Strategy.setWhitelist(alice, true);
        usd3Strategy.setWhitelist(bob, true);
        usd3Strategy.setWhitelist(attacker, true);
        usd3Strategy.setWhitelist(attackerAlt, true);
        vm.stopPrank();
    }

    /**
     * @notice Test if non-depositors can start cooldown
     * @dev This is the first part of the vulnerability - users who never deposited can start cooldown
     */
    function test_nonDepositor_cannot_start_cooldown() public {
        // Bob has never deposited to sUSD3
        assertEq(susd3Strategy.lockedUntil(bob), 0, "Bob should have no lock");
        assertEq(
            IERC20(address(susd3Strategy)).balanceOf(bob),
            0,
            "Bob should have no sUSD3"
        );

        // Bob tries to start cooldown for a large amount - should fail
        vm.prank(bob);
        vm.expectRevert("Insufficient balance for cooldown");
        susd3Strategy.startCooldown(1000e6);

        // Verify cooldown was NOT set
        (uint256 cooldownEnd, uint256 windowEnd, uint256 shares) = susd3Strategy
            .getCooldownStatus(bob);

        assertEq(cooldownEnd, 0, "Cooldown should not be set");
        assertEq(windowEnd, 0, "Window should not be set");
        assertEq(shares, 0, "Cooldown shares should be 0");

        console2.log(
            "VULNERABILITY FIXED: Non-depositor cannot start cooldown"
        );
    }

    /**
     * @notice Test if users can set cooldown for more shares than they own
     * @dev This demonstrates that cooldown shares are not validated against actual balance
     */
    function test_cooldown_cannot_exceed_balance() public {
        // Alice deposits and gets some sUSD3 shares
        vm.startPrank(alice);
        asset.approve(address(usd3Strategy), 1000e6);
        usd3Strategy.deposit(1000e6, alice);

        // Deposit to sUSD3 (limited by subordination ratio)
        IERC20(address(usd3Strategy)).approve(address(susd3Strategy), 150e6);
        susd3Strategy.deposit(100e6, alice);
        vm.stopPrank();

        uint256 aliceShares = IERC20(address(susd3Strategy)).balanceOf(alice);
        console2.log("Alice actual shares:", aliceShares);

        // Wait for lock period to end
        skip(90 days);

        // Alice tries to set cooldown for 10x her balance - should fail
        vm.prank(alice);
        vm.expectRevert("Insufficient balance for cooldown");
        susd3Strategy.startCooldown(aliceShares * 10);

        // Verify she can set cooldown for exact balance
        vm.prank(alice);
        susd3Strategy.startCooldown(aliceShares);

        (, , uint256 cooldownShares) = susd3Strategy.getCooldownStatus(alice);
        assertEq(cooldownShares, aliceShares, "Cooldown shares match balance");

        console2.log(
            "VULNERABILITY FIXED: Cannot set cooldown for more shares than owned"
        );
        console2.log("Cooldown shares set to exact balance:", cooldownShares);
    }

    /**
     * @notice Test the complete attack sequence as described in the report
     * @dev This tests if the attack can actually be executed given the current implementation
     */
    function test_complete_attack_sequence() public {
        console2.log("\n=== Testing Complete Attack Sequence ===");

        // Step 1: Attacker deposits through main address
        vm.startPrank(attacker);
        asset.approve(address(usd3Strategy), 1000e6);
        usd3Strategy.deposit(1000e6, attacker);
        IERC20(address(usd3Strategy)).approve(address(susd3Strategy), 150e6);
        susd3Strategy.deposit(100e6, attacker);
        vm.stopPrank();

        uint256 attackerShares = IERC20(address(susd3Strategy)).balanceOf(
            attacker
        );
        console2.log("Step 1: Attacker deposited, shares:", attackerShares);
        console2.log(
            "Attacker lock ends at:",
            susd3Strategy.lockedUntil(attacker)
        );

        // Step 2: AttackerAlt (who never deposited) starts cooldown
        assertEq(
            susd3Strategy.lockedUntil(attackerAlt),
            0,
            "AttackerAlt should have no lock"
        );
        vm.prank(attackerAlt);
        susd3Strategy.startCooldown(type(uint256).max); // Max uint as in the report

        (
            uint256 cooldownEnd,
            uint256 windowEnd,
            uint256 cooldownShares
        ) = susd3Strategy.getCooldownStatus(attackerAlt);
        console2.log(
            "Step 2: AttackerAlt started cooldown for shares:",
            cooldownShares
        );
        console2.log("Cooldown ends at:", cooldownEnd);
        console2.log("Window ends at:", windowEnd);

        // Step 3: Try to transfer during lock period (should fail)
        console2.log("\nStep 3: Attempting transfer during lock period...");
        vm.prank(attacker);
        vm.expectRevert("sUSD3: Cannot transfer during lock period");
        IERC20(address(susd3Strategy)).transfer(attackerAlt, attackerShares);
        console2.log(
            "Transfer blocked during lock period (GOOD - provides protection)"
        );

        // Step 4: Wait for lock period to end
        skip(90 days);
        console2.log("\nStep 4: Lock period ended, attempting transfer...");

        // Now transfer should work
        vm.prank(attacker);
        IERC20(address(susd3Strategy)).transfer(attackerAlt, attackerShares);
        console2.log("Transfer successful after lock period");

        // Step 5: Check if attackerAlt can withdraw
        console2.log("\nStep 5: Checking withdrawal availability...");

        // Check if cooldown window is still valid
        bool windowExpired = block.timestamp > windowEnd;
        console2.log("Current time:", block.timestamp);
        console2.log("Window expired?", windowExpired);

        if (windowExpired) {
            console2.log(
                "Attack FAILED: Cooldown window expired during 90-day lock wait"
            );
            assertEq(susd3Strategy.availableWithdrawLimit(attackerAlt), 0);
        } else {
            // Window still valid - check withdrawal limit
            uint256 withdrawLimit = susd3Strategy.availableWithdrawLimit(
                attackerAlt
            );
            console2.log("Available withdraw limit:", withdrawLimit);

            if (withdrawLimit > 0) {
                console2.log(
                    "VULNERABILITY: Non-zero withdraw limit despite cooldown > balance"
                );

                // Try actual withdrawal
                vm.startPrank(attackerAlt);
                IERC20(address(susd3Strategy)).approve(
                    address(susd3Strategy),
                    attackerShares
                );

                // This might fail at the TokenizedStrategy level due to balance check
                try
                    susd3Strategy.redeem(
                        attackerShares,
                        attackerAlt,
                        attackerAlt
                    )
                {
                    console2.log(
                        "CRITICAL: Withdrawal succeeded - full bypass achieved!"
                    );
                } catch {
                    console2.log(
                        "Withdrawal failed - likely due to balance validation in redeem()"
                    );
                }
                vm.stopPrank();
            }
        }
    }

    /**
     * @notice Test a more sophisticated attack with proper timing
     * @dev This tests if the attack can work with careful timing coordination
     */
    function test_sophisticated_timing_attack() public {
        console2.log("\n=== Testing Sophisticated Timing Attack ===");

        // Attacker deposits
        vm.startPrank(attacker);
        asset.approve(address(usd3Strategy), 1000e6);
        usd3Strategy.deposit(1000e6, attacker);
        IERC20(address(usd3Strategy)).approve(address(susd3Strategy), 100e6);
        susd3Strategy.deposit(100e6, attacker);
        vm.stopPrank();

        uint256 attackerShares = IERC20(address(susd3Strategy)).balanceOf(
            attacker
        );

        // Wait until close to end of lock period
        skip(90 days - 8 days); // 82 days pass

        // AttackerAlt starts cooldown now (will be ready when lock ends)
        vm.prank(attackerAlt);
        susd3Strategy.startCooldown(attackerShares); // Use exact amount

        // Wait for remaining lock period + cooldown
        skip(8 days); // Now at 90 days (lock ended, cooldown ongoing)

        // Transfer shares
        vm.prank(attacker);
        IERC20(address(susd3Strategy)).transfer(attackerAlt, attackerShares);

        // Wait for cooldown to complete
        skip(6 days); // Total 7 days cooldown from when started

        // Now within valid withdrawal window
        uint256 withdrawLimit = susd3Strategy.availableWithdrawLimit(
            attackerAlt
        );
        console2.log("Withdraw limit for attackerAlt:", withdrawLimit);

        if (withdrawLimit > 0) {
            console2.log(
                "VULNERABILITY ACTIVE: Can withdraw despite never depositing"
            );

            // Attempt withdrawal
            vm.startPrank(attackerAlt);
            IERC20(address(susd3Strategy)).approve(
                address(susd3Strategy),
                attackerShares
            );

            try
                susd3Strategy.redeem(attackerShares, attackerAlt, attackerAlt)
            returns (uint256 assets) {
                console2.log("CRITICAL: Bypass successful! Withdrew:", assets);
                assertGt(assets, 0, "Assets withdrawn");
            } catch Error(string memory reason) {
                console2.log("Withdrawal failed with:", reason);
            }
            vm.stopPrank();
        }
    }

    /**
     * @notice Test that availableWithdrawLimit now works correctly after fix
     * @dev This verifies the fix prevents incorrect withdraw limits
     */
    function test_availableWithdrawLimit_fixed() public {
        // Bob tries to start cooldown without any shares - should fail
        vm.prank(bob);
        vm.expectRevert("Insufficient balance for cooldown");
        susd3Strategy.startCooldown(1000e6);

        // Bob deposits first to get shares
        vm.startPrank(bob);
        asset.approve(address(usd3Strategy), 1000e6);
        usd3Strategy.deposit(1000e6, bob);
        IERC20(address(usd3Strategy)).approve(address(susd3Strategy), 100e6);
        susd3Strategy.deposit(100e6, bob);
        vm.stopPrank();

        uint256 bobBalance = IERC20(address(susd3Strategy)).balanceOf(bob);
        console2.log("Bob's actual balance after deposit:", bobBalance);

        // Wait for lock period
        skip(90 days);

        // Now Bob can start cooldown with his actual balance
        vm.prank(bob);
        susd3Strategy.startCooldown(bobBalance);

        // Wait for cooldown
        skip(7 days);

        // Check withdraw limit - should match his actual shares
        uint256 withdrawLimit = susd3Strategy.availableWithdrawLimit(bob);
        console2.log("Bob's withdraw limit:", withdrawLimit);

        assertGt(withdrawLimit, 0, "Withdraw limit should be non-zero");
        assertEq(
            withdrawLimit,
            bobBalance,
            "Withdraw limit should match balance"
        );

        console2.log(
            "VULNERABILITY FIXED: availableWithdrawLimit returns correct value"
        );
    }
}
